    if(i===0) cctx.moveTo(x,y); else cctx.lineTo(x,y);
  }
  cctx.strokeStyle = simParams ? simParams.color : '#a64dff';
  cctx.lineWidth = 2; cctx.stroke();

  if(playIdx >= 0){
    const px = playIdx / waveform.length * W;
    cctx.beginPath(); cctx.moveTo(px,0); cctx.lineTo(px,H);
    cctx.strokeStyle='rgba(255,80,80,0.95)'; cctx.lineWidth=1.4; cctx.stroke();
  }
}

/* play chirp audio (two oscillators: base + harmonic) and sync visuals */
async function playChirpAudio(m1,m2,spin,color){
  if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  if(audioCtx.state === 'suspended') await audioCtx.resume().catch(()=>{});
  stopChirpAudio();

  const Mc = Math.pow((m1*m2)**(3/5)/(m1+m2)**(1/5),1);
  const fStart = 20 + spin*12;
  const fEnd = 400 + (Mc/30)*220;
  const duration = Math.max(0.8, 3.0 - (Mc/60)); // seconds
  playDurMs = duration * 1000;

  // create oscillators
  osc = audioCtx.createOscillator();
  gainNode = audioCtx.createGain();
  osc.type = 'sine';
  osc.connect(gainNode); gainNode.connect(audioCtx.destination);

  oscHarm = audioCtx.createOscillator();
  gainHarm = audioCtx.createGain();
  oscHarm.type = 'sine';
  oscHarm.connect(gainHarm); gainHarm.connect(audioCtx.destination);

  const now = audioCtx.currentTime;
  osc.frequency.setValueAtTime(Math.max(1,fStart), now);
  osc.frequency.exponentialRampToValueAtTime(Math.max(2,fEnd), now + duration);

  oscHarm.frequency.setValueAtTime(Math.max(2,fStart*2), now);
  oscHarm.frequency.exponentialRampToValueAtTime(Math.max(2, fEnd*2), now + duration);

  gainNode.gain.setValueAtTime(0.0001, now);
  gainNode.gain.linearRampToValueAtTime(0.28, now + 0.03);
  gainNode.gain.exponentialRampToValueAtTime(0.0001, now + duration);

  gainHarm.gain.setValueAtTime(0.0001, now);
  gainHarm.gain.linearRampToValueAtTime(0.06, now + 0.03);
  gainHarm.gain.exponentialRampToValueAtTime(0.0001, now + duration);

  osc.start(now); osc.stop(now + duration + 0.05);
  oscHarm.start(now); oscHarm.stop(now + duration + 0.05);

  // sync visuals
  playStartTime = performance.now();
  function animatePlay(){
    const elapsed = performance.now() - playStartTime;
    if(elapsed >= playDurMs){
      drawChirp(-1);
      document.getElementById('audioState').textContent = 'idle';
      playRAF = null;
      return;
    }
    const prog = elapsed / playDurMs;
    const idx = Math.floor(prog * waveform.length);
    drawChirp(idx);
    drawSummaryGraphs(simParams.color, prog);
    document.getElementById('audioState').textContent = 'playing';
    playRAF = requestAnimationFrame(animatePlay);
  }
  animatePlay();
}

function stopChirpAudio(){
  try{ if(osc) osc.stop(); }catch(e){}
  try{ if(oscHarm) oscHarm.stop(); }catch(e){}
  try{ if(gainNode) gainNode.disconnect(); }catch(e){}
  try{ if(gainHarm) gainHarm.disconnect(); }catch(e){}
  try{ if(osc) osc.disconnect(); }catch(e){}
  try{ if(oscHarm) oscHarm.disconnect(); }catch(e){}
  osc = null; oscHarm = null; gainNode = null; gainHarm = null;
  if(playRAF) { cancelAnimationFrame(playRAF); playRAF = null; }
  drawChirp(-1);
  drawSummaryGraphs(simParams ? simParams.color : '#a64dff', 0);
  document.getElementById('audioState').textContent = 'idle';
}

/* summary graphs (animated by progress) */
function drawSummaryGraphs(accent, progress=0){
  drawGraph(document.getElementById('amplitudeCanvas').getContext('2d'), accent, t => Math.pow(t*(0.3+0.7*progress+0.5), 3) * Math.sin(40*t*Math.PI));
  drawGraph(document.getElementById('energyCanvas').getContext('2d'), accent, t => Math.pow(t*(0.2+0.8*progress+0.4), 2.5) * Math.exp(-3*t*(1 - 0.4*(1-progress))));
  drawGraph(document.getElementById('freqCanvas').getContext('2d'), accent, t => Math.pow(t*(0.6+0.4*progress+0.2), 1.6));
}
function drawGraph(ctx,color,fn){
  const W=ctx.canvas.width, H=ctx.canvas.height; ctx.clearRect(0,0,W,H);
  ctx.beginPath();
  for(let i=0;i<W;i++){
    const t=i/W; const y=H/2 - fn(t) * H/3;
    if(i===0) ctx.moveTo(i,y); else ctx.lineTo(i,y);
  }
  ctx.strokeStyle=color; ctx.lineWidth=2; ctx.stroke();
}

/* -----------------------
   UI wiring: event handlers
   ----------------------- */
const spinInput = document.getElementById('spinInput');
const spinVal = document.getElementById('spinVal');
spinInput.addEventListener('input', ()=> spinVal.textContent = Number(spinInput.value).toFixed(2));

eventSelect.addEventListener('change', ()=> {
  const key = eventSelect.value;
  const ev = events[key];
  document.getElementById('eventDescription').textContent = ev.desc;
  m1Input.value = ev.m1; m2Input.value = ev.m2; spinInput.value = ev.spin; spinVal.textContent = Number(ev.spin).toFixed(2);
  document.getElementById('spinOut').textContent = ev.spin;
  // regen waveform and update summary visuals
  simParams = { m1:ev.m1, m2:ev.m2, spin:ev.spin, color:ev.color, sep:12 };
  generateWaveformSamples(ev.m1, ev.m2, ev.spin);
  drawSummaryGraphs(ev.color, 0);
  drawChirp(-1);
  // prepare orbit (static) until Run Simulation clicked
  startOrbitSim(ev.m1, ev.m2, ev.spin, ev.color, 12); // start orbit (it will animate; run sim will inspiral)
});

const m1Input = document.getElementById('m1Input');
const m2Input = document.getElementById('m2Input');
const sepInput = document.getElementById('sepInput');

document.getElementById('runSimBtn').addEventListener('click', ()=>{
  const key = eventSelect.value;
  const m1 = clamp(parseFloat(m1Input.value) || 30, 1, 1e6);
  const m2 = clamp(parseFloat(m2Input.value) || 30, 1, 1e6);
  const spin = clamp(parseFloat(spinInput.value) || 0.5, 0, 1);
  const color = (events[key] && events[key].color) ? events[key].color : '#a64dff';
  // store to events['Custom'] if user changed
  events['Custom'] = { m1, m2, spin, color, desc: `Custom: ${m1} + ${m2} M☉, spin ${spin}` };
  eventSelect.value = 'Custom';
  document.getElementById('eventDescription').textContent = events['Custom'].desc;
  // waveform + orbit inspiral
  generateWaveformSamples(m1,m2,spin);
  simParams = { m1,m2,spin,color,sep: Number(sepInput.value) || 12 };
  startOrbitSim(m1,m2,spin,color, simParams.sep);
  drawSummaryGraphs(color, 0);
});

<script>
/* -----------------------
   Tabs handling
----------------------- */
document.querySelectorAll('.tabButton').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    document.querySelectorAll('.tabButton').forEach(b=>b.classList.remove('active'));
    btn.classList.add('active');
    document.querySelectorAll('.tabContent').forEach(c=>c.style.display='none');
    document.getElementById(btn.dataset.tab).style.display='block';
    tooltip.style.display='none';
  });
});

/* -----------------------
   Overview drawing (same)
----------------------- */
const bhCanvas=document.getElementById('bhCanvas');
const bhCtx=bhCanvas.getContext('2d');
const bhW=bhCanvas.width, bhH=bhCanvas.height;
const bhCx=bhW/2, bhCy=bhH/2;
const horizonR=70;
let bhHotAngle=0;
function drawOverview(){
  bhCtx.clearRect(0,0,bhW,bhH);
  const g=bhCtx.createRadialGradient(bhCx,bhCy,10,bhCx,bhCy,300);
  g.addColorStop(0,'#070012'); g.addColorStop(1,'#010006');
  bhCtx.fillStyle=g; bhCtx.fillRect(0,0,bhW,bhH);
  // horizon
  bhCtx.beginPath(); bhCtx.arc(bhCx,bhCy,horizonR,0,Math.PI*2);
  bhCtx.strokeStyle='rgba(140,80,255,0.35)'; bhCtx.lineWidth=2; bhCtx.stroke();
  // accretion
  for(let i=0;i<40;i++){
    bhCtx.beginPath(); bhCtx.arc(bhCx,bhCy,horizonR+8+i*3,0,Math.PI*2);
    bhCtx.strokeStyle=`rgba(255,180,80,${0.006+i*0.0006})`; bhCtx.stroke();
  }
  // hotspot trail
  const hx = bhCx + Math.cos(bhHotAngle)*110;
  const hy = bhCy + Math.sin(bhHotAngle)*34;
  for(let k=0;k<8;k++){
    const t=bhHotAngle-k*0.1;
    const tx=bhCx+Math.cos(t)*(110-k*6);
    const ty=bhCy+Math.sin(t)*(34-k*2);
    bhCtx.beginPath(); bhCtx.arc(tx,ty,4-k*0.36,0,Math.PI*2);
    bhCtx.fillStyle=`rgba(255,220,180,${0.12*(8-k)})`; bhCtx.fill();
  }
  bhCtx.beginPath(); bhCtx.arc(hx,hy,6,0,Math.PI*2); bhCtx.fillStyle='#ffcc99'; bhCtx.fill();
  bhHotAngle+=0.026;
  requestAnimationFrame(drawOverview);
}
drawOverview();

/* Tooltip legend */
const tooltip=document.getElementById('tooltip');
const tooltipData={
  "eh":"Event horizon — radius where escape speed = c.",
  "ad":"Accretion disk — hot, rotating plasma.",
  "jet":"Relativistic jet — outflow powered by BH spin."
};
document.querySelectorAll('.legend div').forEach(div=>{
  const key=div.dataset.tooltip;
  div.addEventListener('mouseenter',e=>{
    tooltip.textContent=tooltipData[key]||'';
    tooltip.style.left=(e.clientX+12)+'px';
    tooltip.style.top=(e.clientY+12)+'px';
    tooltip.style.display='block';
  });
  div.addEventListener('mousemove',e=>{
    tooltip.style.left=(e.clientX+12)+'px';
    tooltip.style.top=(e.clientY+12)+'px';
  });
  div.addEventListener('mouseleave',()=>tooltip.style.display='none');
});

/* Calculator */
document.getElementById('runCalcBtn').addEventListener('click',()=>{
  const G=6.67430e-11, M=4.3e6*1.989e30, c=3e8;
  const r=Number(radiusInput.value)||7.8e17;
  const rho=Number(densityInput.value)||1e-21;
  const val=1-(G*M)/(r*c*c);
  const gamma=val>0?Math.sqrt(val):0;
  const Gamma_dark=(1+1e21*rho);
  calcResults.innerHTML=`γ=<b>${gamma.toFixed(6)}</b> | Γ_dark≈<b>${Gamma_dark.toExponential(2)}</b>`;
});

/* -----------------------
   EVENTS — with precise data
----------------------- */
const events={
  "GW150914":{m1:36,m2:29,spin:0.33,dist:440,chirp:28,freq:150,h:1e-21,energy:3,color:"#a64dff",desc:"First detection (2015)"},
  "GW151226":{m1:14,m2:7.5,spin:0.2,dist:440,chirp:9,freq:220,h:3e-22,energy:1,color:"#33ccff",desc:"Second detection"},
  "GW170104":{m1:31,m2:19,spin:0.45,dist:880,chirp:21,freq:200,h:7e-22,energy:2,color:"#00ccff",desc:"Detected Jan 2017"},
  "GW170814":{m1:30.5,m2:25.3,spin:0.06,dist:540,chirp:24.2,freq:190,h:8e-22,energy:2.7,color:"#ffcc00",desc:"First triple-detector event"},
  "GW170817":{m1:1.46,m2:1.27,spin:0.05,dist:40,chirp:1.19,freq:400,h:2e-23,energy:0.025,color:"#66ff99",desc:"Binary neutron star"},
  "GW190412":{m1:30,m2:8,spin:0.25,dist:740,chirp:13,freq:230,h:5e-22,energy:1.6,color:"#ffaa66",desc:"Asymmetric BH merger"},
  "GW190521":{m1:85,m2:66,spin:0.7,dist:5300,chirp:64,freq:60,h:3e-21,energy:8,color:"#ff9933",desc:"Most massive detected"},
  "GW190814":{m1:23,m2:2.6,spin:0.05,dist:240,chirp:6.1,freq:300,h:6e-22,energy:0.6,color:"#ffd166",desc:"BH + compact object"},
  "Custom":{m1:30,m2:30,spin:0.5,dist:500,chirp:26,freq:200,h:8e-22,energy:2,color:"#b666ff",desc:"User-defined system"}
};

const eventSelect=document.getElementById('eventSelect');
for(const k in events){
  const o=document.createElement('option');
  o.value=k; o.textContent=k; eventSelect.appendChild(o);
}

/* Populate concise info table */
function updateEventTable(ev){
  document.getElementById('chirpMass').textContent=ev.chirp.toFixed(2)+" M☉";
  document.getElementById('freqRange').textContent=ev.freq+" Hz";
  document.getElementById('gwStrain').textContent=ev.h.toExponential(2);
  document.getElementById('distance').textContent=ev.dist+" Mpc";
  document.getElementById('spinOut').textContent=ev.spin.toFixed(2);
  document.getElementById('energyOut').textContent=ev.energy+" M☉c²";
}

/* simple orbit + chirp visuals (unchanged core) */
const orbitCanvas=document.getElementById('orbitCanvas');
const ox=orbitCanvas.getContext('2d');
let orbitAnim=null; let simParams=null;
function startOrbitSim(ev){
  cancelAnimationFrame(orbitAnim);
  let angle=0;
  const cx=orbitCanvas.width/2, cy=orbitCanvas.height/2;
  function frame(){
    ox.clearRect(0,0,orbitCanvas.width,orbitCanvas.height);
    ox.fillStyle="rgba(10,0,20,0.7)"; ox.fillRect(0,0,orbitCanvas.width,orbitCanvas.height);
    const r=120;
    const x1=cx+Math.cos(angle)*r, y1=cy+Math.sin(angle)*r;
    const x2=cx-Math.cos(angle)*r, y2=cy-Math.sin(angle)*r;
    ox.beginPath(); ox.arc(x1,y1,10,0,Math.PI*2); ox.fillStyle=ev.color; ox.fill();
    ox.beginPath(); ox.arc(x2,y2,16,0,Math.PI*2); ox.fillStyle="#ffffff33"; ox.fill();
    angle+=0.02;
    orbitAnim=requestAnimationFrame(frame);
  }
  frame();
}

/* Chirp waveform */
const chirpCanvas=document.getElementById('chirpCanvas');
const cctx=chirpCanvas.getContext('2d');
function drawChirp(ev){
  const W=chirpCanvas.width, H=chirpCanvas.height;
  cctx.clearRect(0,0,W,H);
  cctx.beginPath();
  for(let i=0;i<W;i++){
    const t=i/W;
    const amp=Math.pow(t,2)*Math.exp(-1.5*(1-t));
    const freq=ev.freq*(1+2*t);
    const y=H/2-amp*Math.sin(2*Math.PI*freq*t/300)*H*0.4;
    i===0?cctx.moveTo(i,y):cctx.lineTo(i,y);
  }
  cctx.strokeStyle=ev.color; cctx.lineWidth=2; cctx.stroke();
}

/* Event change */
eventSelect.addEventListener('change',()=>{
  const ev=events[eventSelect.value];
  document.getElementById('eventDescription').textContent=ev.desc;
  updateEventTable(ev);
  drawChirp(ev);
  startOrbitSim(ev);
});

/* default event */
eventSelect.value='GW150914';
eventSelect.dispatchEvent(new Event('change'));

/* Helper */
function clamp(x,a,b){return Math.max(a,Math.min(b,x));}
</script>
</body>
</html>
