<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ðŸŒ€ BBH Simulation â€“ Offline Mock Gravitational Wave</title>

  <!-- ðŸ§  Embedded Plotly (offline version) -->
  <script type="text/javascript">
  /*! Plotly.js basic build (minified) */
  // The minified Plotly library is very large (over 1 MB), so instead of pasting the whole thing here,
  // this simplified version will use a fallback inline script.
  // If offline, we generate the plot manually with simple Canvas drawing.
  </script>

  <style>
    body {
      font-family: system-ui, sans-serif;
      margin: 0;
      background: #0b0b0b;
      color: #e6e6e6;
      text-align: center;
      padding: 1.5rem;
    }
    h1 {
      color: #00b4ff;
      font-size: 1.5rem;
    }
    canvas {
      display: block;
      margin: 1rem auto;
      background: #111;
      border-radius: 12px;
      max-width: 800px;
      width: 95%;
      height: 400px;
    }
    footer {
      margin-top: 2rem;
      font-size: 0.9rem;
      color: #aaa;
    }
  </style>
</head>
<body>
  <h1>ðŸŒ€ Mock Gravitational Wave Strain</h1>
  <p>(Offline version â€“ no internet required)</p>
  <canvas id="gwCanvas" width="800" height="400"></canvas>

  <script>
    // Simple offline plotting using Canvas API
    const canvas = document.getElementById('gwCanvas');
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;

    // Generate mock waveform data
    const N = 2000;
    const t = Array.from({ length: N }, (_, i) => i * 0.05);
    const hPlus = t.map(x => Math.sin(0.2 * x) * Math.exp(-0.002 * x));
    const hCross = t.map(x => Math.cos(0.2 * x) * Math.exp(-0.002 * x));

    // Normalize for plotting
    const maxVal = Math.max(...hPlus.map(Math.abs), ...hCross.map(Math.abs));
    const scaleY = height / (2.2 * maxVal);

    function drawWave(yData, color, offset) {
      ctx.beginPath();
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      const stepX = width / N;
      for (let i = 0; i < N; i++) {
        const x = i * stepX;
        const y = height / 2 - (yData[i] * scaleY) + offset;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();
    }

    // Draw background grid
    ctx.fillStyle = "#111";
    ctx.fillRect(0, 0, width, height);
    ctx.strokeStyle = "#333";
    ctx.lineWidth = 1;
    for (let i = 0; i < 10; i++) {
      const y = (i / 10) * height;
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(width, y);
      ctx.stroke();
    }

    // Draw both polarizations
    drawWave(hPlus, "#00b4ff", -5);
    drawWave(hCross, "#ffffff", +5);

    // Add labels
    ctx.fillStyle = "#e6e6e6";
    ctx.font = "16px system-ui";
    ctx.fillText("hâ‚Š (blue)", 20, 25);
    ctx.fillText("hÃ— (white, dotted)", 20, 45);
  </script>

  <footer>
    <p>BBH-Sim Open Project â€¢ Offline Mock Visualization</p>
  </footer>
</body>
</html>

