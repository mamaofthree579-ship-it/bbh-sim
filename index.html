<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>BBH Simulator ‚Äî Overview & Events</title>
<style>
  :root{
    --bg:#05000a; --panel:#1a001f; --accent:#8000ff; --muted:#33003d; --text:#e5ccff;
    --h1:#ff66ff; --h2:#00ccff; --custom:#ffd166;
  }
  body{margin:0;font-family:Inter,Arial,Helvetica,sans-serif;background:var(--bg);color:var(--text);-webkit-font-smoothing:antialiased;}
  .tabs{display:flex;background:var(--panel);border-bottom:2px solid var(--muted);}
  .tabButton{flex:1;padding:12px;cursor:pointer;background:transparent;border:0;color:var(--text);font-weight:700}
  .tabButton.active{background:var(--accent);color:#fff}
  .container{padding:18px}
  h2{margin:6px 0 10px;color:var(--text)}
  canvas{display:block;margin:12px auto;border-radius:8px;background:radial-gradient(circle at center,#14001a 0%, #05000a 100%);box-shadow:0 6px 18px rgba(0,0,0,0.6);}
  label,input,select,button{margin:6px 6px 6px 0}
  input[type=range]{vertical-align:middle}
  .panel{background:rgba(30,0,40,0.6);padding:10px;border-radius:8px;border:1px solid var(--muted);max-width:960px;margin:12px auto}
  .row{display:flex;gap:8px;align-items:center}
  .small{font-size:0.9rem;color:#d6c7ff}
  .muted{color:#bdaeff}
  .btn{background:var(--accent);border-radius:6px;color:white;padding:8px 12px;border:0;cursor:pointer}
  .btn.secondary{background:#444}
  .legend{display:flex;gap:12px;align-items:center;justify-content:center;margin-top:8px;color:var(--text);font-size:0.95rem}
  .swatch{width:18px;height:10px;border-radius:4px;display:inline-block;margin-right:6px;vertical-align:middle}
  #status{font-size:0.9rem;color:#ffd;}
</style>
</head>
<body>

<!-- Tabs -->
<div class="tabs">
  <button class="tabButton active" data-tab="overviewTab">Overview</button>
  <button class="tabButton" data-tab="eventsTab">Events</button>
</div>

<!-- Overview -->
<div id="overviewTab" class="container tabContent" style="display:block">
  <h2>üåå Black Hole Overview</h2>
  <div class="panel">
    <p class="small">A rotating black hole with an accretion disk. Outlined regions are subtle so you can explain them using the mathematical notes.</p>
    <canvas id="bhCanvas" width="920" height="420"></canvas>
    <div class="legend" aria-hidden="true">
      <div><span class="swatch" style="background:rgba(140,80,255,0.35);border:1px solid rgba(140,80,255,0.2)"></span>Event Horizon</div>
      <div><span class="swatch" style="background:rgba(255,180,80,0.22);border:1px solid rgba(255,180,80,0.18)"></span>Accretion Disk</div>
      <div><span class="swatch" style="background:rgba(120,200,255,0.18);border:1px solid rgba(120,200,255,0.12)"></span>Relativistic Jet</div>
    </div>
  </div>
</div>

<!-- Events -->
<div id="eventsTab" class="container tabContent" style="display:none">
  <h2>üí´ Gravitational-Wave Events</h2>

  <div class="panel">
    <div class="row">
      <label for="eventSelect">Event</label>
      <select id="eventSelect"></select>

      <button id="runCustomBtn" class="btn">Run Custom</button>
      <button id="resetBtn" class="btn secondary">Reset Simulator</button>

      <div style="margin-left:auto" id="status">Audio: <span id="audioState">idle</span></div>
    </div>

    <div class="row" style="margin-top:8px">
      <label>M‚ÇÅ (M‚òâ)</label><input id="m1Input" type="number" value="30" step="0.1" min="1">
      <label>M‚ÇÇ (M‚òâ)</label><input id="m2Input" type="number" value="30" step="0.1" min="1">
      <label>Spin a*</label><input id="spinInput" type="range" min="0" max="1" step="0.01" value="0.5">
      <span id="spinVal" class="muted">0.50</span>
    </div>

    <canvas id="orbitCanvas" width="920" height="380"></canvas>

    <div class="row">
      <div style="flex:1">
        <canvas id="chirpCanvas" width="920" height="180"></canvas>
        <div style="margin-top:6px">
          <button id="playChirpBtn" class="btn">üîä Play Chirp</button>
          <button id="stopChirpBtn" class="btn secondary">‚èπ Stop</button>
          <span class="muted" style="margin-left:10px">Playhead on chirp canvas</span>
        </div>
      </div>

      <div style="width:340px;margin-left:16px">
        <div class="panel">
          <strong>Event Info</strong>
          <p id="eventDescription" class="small muted">‚Äî</p>
          <table style="width:100%;border-collapse:collapse;margin-top:8px;color:var(--text)">
            <tr><td class="small muted">Chirp mass</td><td id="chirpMass" style="text-align:right">‚Äî</td></tr>
            <tr><td class="small muted">Freq range</td><td id="freqRange" style="text-align:right">‚Äî</td></tr>
            <tr><td class="small muted">Estimated h</td><td id="gwStrain" style="text-align:right">‚Äî</td></tr>
            <tr><td class="small muted">Distance est.</td><td id="distance" style="text-align:right">‚Äî</td></tr>
          </table>
        </div>
      </div>
    </div>

    <div class="panel" style="margin-top:12px">
      <strong>Scientific Summary</strong>
      <h4 class="small muted">Chirp Amplitude</h4>
      <canvas id="amplitudeCanvas" width="920" height="110"></canvas>
      <h4 class="small muted">Energy Loss</h4>
      <canvas id="energyCanvas" width="920" height="110"></canvas>
      <h4 class="small muted">Frequency evolution</h4>
      <canvas id="freqCanvas" width="920" height="110"></canvas>
    </div>
  </div>
</div>

<script>
/* -------------------------------
   Utility: tabs and small helpers
   ------------------------------- */
const tabButtons = document.querySelectorAll('.tabButton');
const tabContents = document.querySelectorAll('.tabContent');
tabButtons.forEach(btn=>btn.addEventListener('click', ()=>{
  tabButtons.forEach(b=>b.classList.remove('active'));
  btn.classList.add('active');
  tabContents.forEach(tc=>tc.style.display='none');
  document.getElementById(btn.dataset.tab).style.display='block';
}));

function clamp(x,a,b){ return Math.max(a,Math.min(b,x)); }

/* -------------------------------
   Overview: starfield + BH + outlines
   ------------------------------- */
const bhCanvas = document.getElementById('bhCanvas');
const bhCtx = bhCanvas.getContext('2d');
const bhW = bhCanvas.width, bhH = bhCanvas.height;
const bhCx = bhW/2, bhCy = bhH/2;
const horizonR = 70;
const stars = Array.from({length:170}, ()=>({
  x: Math.random()*bhW, y: Math.random()*bhH, r: 0.5+Math.random()*1.1, phi: Math.random()*Math.PI*2, vx:(Math.random()-0.5)*0.06
}));
let bhHotAngle = 0;

function drawOverview(){
  bhCtx.clearRect(0,0,bhW,bhH);

  // background gradient
  const g = bhCtx.createRadialGradient(bhCx,bhCy,10,bhCx,bhCy,300);
  g.addColorStop(0,'#070012'); g.addColorStop(1,'#010006');
  bhCtx.fillStyle = g; bhCtx.fillRect(0,0,bhW,bhH);

  // stars (mask inside disk/horizon)
  for(const s of stars){
    s.phi += 0.02 + Math.random()*0.01;
    s.x += s.vx;
    if(s.x < -2) s.x = bhW + 2;
    if(s.x > bhW + 2) s.x = -2;
    const d = Math.hypot(s.x - bhCx, s.y - bhCy);
    if(d > horizonR + 12){
      bhCtx.beginPath();
      bhCtx.fillStyle = `rgba(255,255,255,${0.45 + 0.5*Math.sin(s.phi)})`;
      bhCtx.arc(s.x,s.y,s.r,0,Math.PI*2); bhCtx.fill();
    }
  }

  // subtle accretion disk highlight (amber)
  for(let i=0;i<40;i++){
    bhCtx.beginPath();
    bhCtx.arc(bhCx, bhCy, horizonR + 8 + i*3, 0, Math.PI*2);
    bhCtx.strokeStyle = `rgba(255,180,80,${0.006 + i*0.0006})`;
    bhCtx.stroke();
  }

  // event horizon outline (violet)
  bhCtx.beginPath();
  bhCtx.arc(bhCx, bhCy, horizonR, 0, Math.PI*2);
  bhCtx.strokeStyle = 'rgba(140,80,255,0.35)';
  bhCtx.lineWidth = 2;
  bhCtx.stroke();

  // jet cone (soft blue), vertical
  bhCtx.beginPath();
  bhCtx.moveTo(bhCx-6,0); bhCtx.lineTo(bhCx+6,0);
  bhCtx.fillStyle = 'rgba(120,200,255,0.06)';
  bhCtx.fillRect(bhCx-5, 0, 10, bhCy-120);

  // central darkness (horizon)
  bhCtx.beginPath();
  bhCtx.arc(bhCx,bhCy,horizonR,0,Math.PI*2);
  bhCtx.fillStyle = 'black'; bhCtx.fill();

  // accretion disk brightened ring near horizon
  bhCtx.beginPath();
  bhCtx.arc(bhCx,bhCy,horizonR+6,0,Math.PI*2);
  bhCtx.strokeStyle = 'rgba(255,200,120,0.08)'; bhCtx.lineWidth = 3; bhCtx.stroke();

  // small orbiting hotspot to show motion
  const hx = bhCx + Math.cos(bhHotAngle) * 110;
  const hy = bhCy + Math.sin(bhHotAngle) * 34;
  bhCtx.beginPath(); bhCtx.arc(hx,hy,6,0,Math.PI*2);
  bhCtx.fillStyle = '#ffcc99'; bhCtx.fill();

  bhHotAngle += 0.026;

  requestAnimationFrame(drawOverview);
}
drawOverview();

/* -------------------------------
   Events: constants, events DB, colors
   ------------------------------- */
const eventSelect = document.getElementById('eventSelect');
const events = {
  "GW150914": { m1:36, m2:29, spin:0.3, color: getComputedStyle(document.documentElement).getPropertyValue('--h1') || '#ff66ff', desc: "GW150914 ‚Äî first detection (2015): 36 + 29 M‚òâ." },
  "GW170104": { m1:31, m2:19, spin:0.45, color: getComputedStyle(document.documentElement).getPropertyValue('--h2') || '#00ccff', desc: "GW170104 ‚Äî 31 + 19 M‚òâ (2017)." },
  "Custom":    { m1:30, m2:30, spin:0.5, color: getComputedStyle(document.documentElement).getPropertyValue('--custom') || '#ffd166', desc: "Custom system." }
};
for(const k in events){ const o=document.createElement('option'); o.value=k; o.textContent=k; eventSelect.appendChild(o); }

/* -------------------------------
   Orbit animation + fading trails
   ------------------------------- */
const orbitCanvas = document.getElementById('orbitCanvas');
const ox = orbitCanvas.getContext('2d');
const orbitW = orbitCanvas.width, orbitH = orbitCanvas.height;
let angle = 0;
let trailsA = [], trailsB = [];
const TRAIL_MAX = 180;
let currentAnimationHandle = null;

function startOrbit(m1,m2,spin,accent){
  // cancel previous
  if(currentAnimationHandle) cancelAnimationFrame(currentAnimationHandle);
  // clear trails
  trailsA = []; trailsB = [];

  function frame(){
    // background
    ox.clearRect(0,0,orbitW,orbitH);
    // gradient
    const g = ox.createRadialGradient(orbitW/2, orbitH/2, 20, orbitW/2, orbitH/2, 500);
    g.addColorStop(0,'rgba(20,0,40,0.6)'); g.addColorStop(1,'rgba(0,0,0,1)');
    ox.fillStyle = g; ox.fillRect(0,0,orbitW,orbitH);

    // orbits
    const cx = orbitW/2, cy = orbitH/2;
    const rA = 80, rB = 160;
    const xA = cx + Math.cos(angle) * rA, yA = cy + Math.sin(angle) * rA;
    const xB = cx - Math.cos(angle) * rB, yB = cy - Math.sin(angle) * rB;

    // record trails
    trailsA.push({x:xA,y:yA});
    trailsB.push({x:xB,y:yB});
    if(trailsA.length > TRAIL_MAX) trailsA.shift();
    if(trailsB.length > TRAIL_MAX) trailsB.shift();

    // draw faded trail (older = more transparent)
    for(let i=0;i<trailsA.length;i++){
      const a = i / trailsA.length;
      ox.fillStyle = hexToRgba(accent, 0.15 * a);
      ox.fillRect(trailsA[i].x-1, trailsA[i].y-1, 3, 3);
    }
    for(let i=0;i<trailsB.length;i++){
      const a = i / trailsB.length;
      ox.fillStyle = hexToRgba(accent, 0.18 * a);
      ox.fillRect(trailsB[i].x-1, trailsB[i].y-1, 4, 4);
    }

    // draw bodies
    ox.beginPath(); ox.arc(xA,yA,12,0,Math.PI*2); ox.fillStyle = accent; ox.fill();
    ox.beginPath(); ox.arc(xB,yB,18,0,Math.PI*2); ox.fillStyle = shadeColor(accent, -20); ox.fill();

    // small frame-drag accent
    ox.beginPath(); ox.arc(cx + Math.cos(angle*1.3 + spin)* (rA*1.05), cy + Math.sin(angle*1.3 + spin)*(rA*0.58), 4, 0, Math.PI*2);
    ox.fillStyle = 'rgba(255,220,180,0.7)'; ox.fill();

    // advance angle (spin increases orbital speed a bit)
    angle += 0.018 + spin * 0.012;

    currentAnimationHandle = requestAnimationFrame(frame);
  }
  frame();
}

/* -------------------------------
   Chirp waveform visuals + audio sync
   ------------------------------- */
const chirpCanvas = document.getElementById('chirpCanvas');
const cctx = chirpCanvas.getContext('2d');
let waveform = new Float32Array(1000); // samples for drawing
let audioCtx = null;
let osc = null, gainNode = null;
let playStart = 0, playDur = 0, playRAF = null;
let currentAccent = '#ff66ff';

function generateWaveformSamples(m1,m2,spin){
  const N = waveform.length;
  const Mc = Math.pow((m1*m2)**(3/5)/(m1+m2)**(1/5),1);
  const f0 = 20 + spin*15;
  const f1 = 300 + (Mc/30)*300;
  for(let i=0;i<N;i++){
    const t = i / N;
    const env = Math.pow(t,2) * Math.exp(-1.2 * (1-t));
    const freq = f0 + Math.pow(t,1.6) * (f1 - f0);
    waveform[i] = env * Math.sin(2*Math.PI * freq * t * 1.6);
  }
  drawChirp(-1);
}

function drawChirp(playIndex = -1){
  const W = chirpCanvas.width, H = chirpCanvas.height;
  cctx.clearRect(0,0,W,H);
  cctx.beginPath();
  const N = waveform.length;
  for(let i=0;i<N;i++){
    const x = i / N * W;
    const y = H/2 - waveform[i] * (H/2) * 0.9;
    if(i===0) cctx.moveTo(x,y); else cctx.lineTo(x,y);
  }
  // stroke with accent
  cctx.strokeStyle = currentAccent;
  cctx.lineWidth = 2;
  cctx.stroke();

  // playhead
  if(playIndex >= 0){
    const px = playIndex / waveform.length * W;
    cctx.beginPath(); cctx.moveTo(px,0); cctx.lineTo(px,H);
    cctx.strokeStyle = 'rgba(255,80,80,0.9)'; cctx.lineWidth = 1.5; cctx.stroke();
  }
}

/* audio-safe play function (resumes context after user gesture) */
async function playChirpAudio(m1,m2,spin,accent){
  // ensure audio context exists and is resumed
  if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  if(audioCtx.state === 'suspended') await audioCtx.resume();

  // compute parameters
  const Mc = Math.pow((m1*m2)**(3/5)/(m1+m2)**(1/5),1);
  const fStart = 25 + spin*20;
  const fEnd = 250 + (Mc/30)*300;
  const duration = Math.max(0.6, 3.0 - (Mc/40));

  // stop previous
  stopChirpAudio();

  // oscillator + gain
  osc = audioCtx.createOscillator();
  gainNode = audioCtx.createGain();
  osc.type = 'sine';
  osc.connect(gainNode); gainNode.connect(audioCtx.destination);

  // schedule sweep + envelope
  const now = audioCtx.currentTime;
  osc.frequency.setValueAtTime(fStart, now);
  osc.frequency.exponentialRampToValueAtTime(Math.max(fEnd, fStart+1), now + duration);

  gainNode.gain.setValueAtTime(0.0001, now);
  gainNode.gain.linearRampToValueAtTime(0.18, now + 0.02);
  gainNode.gain.exponentialRampToValueAtTime(0.0001, now + duration);

  osc.start(now);
  osc.stop(now + duration + 0.05);

  // visual playhead animation synchronized
  playStart = performance.now();
  playDur = duration * 1000;
  audioState.textContent = 'playing';
  animatePlayhead();
}

function stopChirpAudio(){
  try{ if(osc) osc.stop(); }catch(e){}
  try{ if(gainNode) gainNode.disconnect(); }catch(e){}
  try{ if(osc) osc.disconnect(); }catch(e){}
  osc = null; gainNode = null;
  audioState.textContent = 'idle';
  if(playRAF) { cancelAnimationFrame(playRAF); playRAF = null; drawChirp(-1); }
}

function animatePlayhead(){
  function step(){
    const now = performance.now();
    const elapsed = now - playStart;
    if(elapsed > playDur){
      stopChirpAudio();
      return;
    }
    const idx = Math.floor((elapsed / playDur) * waveform.length);
    drawChirp(idx);
    // also draw dynamic pulse overlay to emphasize freq evolution:
    drawPulseOverlay(elapsed / playDur);
    playRAF = requestAnimationFrame(step);
  }
  step();
}

/* pulse overlay: subtle grid/pulse colored by accent and progress */
function drawPulseOverlay(progress){
  const W = chirpCanvas.width, H = chirpCanvas.height;
  // semi-transparent pulse
  const alpha = 0.18 * (1 - progress*0.9);
  cctx.fillStyle = hexToRgba(currentAccent, alpha);
  // draw a vertical gaussian-ish pulse at playhead
  const centerX = progress * W;
  const width = Math.max(8, 0.06 * W * (0.4 + progress));
  const g = cctx.createLinearGradient(centerX - width, 0, centerX + width, 0);
  g.addColorStop(0, 'rgba(0,0,0,0)');
  g.addColorStop(0.4, hexToRgba(currentAccent, alpha*0.6));
  g.addColorStop(0.6, hexToRgba(currentAccent, alpha*0.6));
  g.addColorStop(1, 'rgba(0,0,0,0)');
  cctx.fillStyle = g;
  cctx.fillRect(centerX - width, 0, width*2, H);
}

/* -------------------------------
   Summary graphs drawing (colored)
   ------------------------------- */
function drawSummaryGraphs(accent){
  const ampCtx = document.getElementById('amplitudeCanvas').getContext('2d');
  const engCtx = document.getElementById('energyCanvas').getContext('2d');
  const fqCtx  = document.getElementById('freqCanvas').getContext('2d');
  techDraw(ampCtx, accent, t => Math.pow(t, 3) * Math.sin(40*t*Math.PI));
  techDraw(engCtx, accent, t => Math.pow(t, 2.5) * Math.exp(-3*t));
  techDraw(fqCtx,  accent, t => Math.pow(t, 1.6));
}
function techDraw(ctx, color, fn){
  const W = ctx.canvas.width, H = ctx.canvas.height;
  ctx.clearRect(0,0,W,H);
  ctx.beginPath();
  for(let i=0;i<W;i++){
    const t = i / W;
    const y = H/2 - fn(t) * H/3;
    if(i===0) ctx.moveTo(i,y); else ctx.lineTo(i,y);
  }
  ctx.strokeStyle = color; ctx.lineWidth = 2; ctx.stroke();
}

/* -------------------------------
   UI wiring, event handling
   ------------------------------- */
const runCustomBtn = document.getElementById('runCustomBtn');
const resetBtn = document.getElementById('resetBtn');
const playChirpBtn = document.getElementById('playChirpBtn');
const stopChirpBtn = document.getElementById('stopChirpBtn');
const m1Input = document.getElementById('m1Input');
const m2Input = document.getElementById('m2Input');
const spinInput = document.getElementById('spinInput');
const spinVal = document.getElementById('spinVal');
const audioState = document.getElementById('audioState');

spinVal.textContent = Number(spinInput.value).toFixed(2);
spinInput.addEventListener('input', ()=> spinVal.textContent = Number(spinInput.value).toFixed(2) );

/* helper to convert hex or CSS color to rgba string */
function hexToRgba(hex, alpha=1.0){
  // hex may be like '#rrggbb' or 'rgb(...)' ‚Äî try to normalize
  if(!hex) return `rgba(200,200,200,${alpha})`;
  // if hex starts with rgb/rgba just return with alpha applied if needed
  if(hex.startsWith('rgb')) {
    // remove 'rgb(' or 'rgba(' and parse numbers
    const nums = hex.replace(/rgba?|\(|\)|\s/g,'').split(',').map(Number);
    return `rgba(${nums[0]},${nums[1]},${nums[2]},${alpha})`;
  }
  const h = hex.replace('#','');
  const r = parseInt(h.substring(0,2),16), g = parseInt(h.substring(2,4),16), b = parseInt(h.substring(4,6),16);
  return `rgba(${r},${g},${b},${alpha})`;
}
function shadeColor(hex, percent) {
  // naive shade for fill of second body: percent negative to darken
  if(!hex.startsWith('#')) return hex;
  const h = hex.replace('#','');
  const r = clamp(parseInt(h.substring(0,2),16) + Math.round(2.55*percent),0,255);
  const g = clamp(parseInt(h.substring(2,4),16) + Math.round(2.55*percent),0,255);
  const b = clamp(parseInt(h.substring(4,6),16) + Math.round(2.55*percent),0,255);
  return `rgb(${r},${g},${b})`;
}

/* load event into UI and start visuals */
function loadEvent(key){
  const ev = events[key];
  if(!ev) return;
  eventSelect.value = key;
  m1Input.value = ev.m1; m2Input.value = ev.m2; spinInput.value = ev.spin; spinVal.textContent = Number(ev.spin).toFixed(2);
  document.getElementById('eventDescription').textContent = ev.desc;
  currentAccent = ev.color;
  // generate waveform (samples) & graphs
  generateWaveformSamples(ev.m1, ev.m2, ev.spin);
  drawSummaryGraphs(ev.color);
  // start orbit with this accent
  startOrbit(ev.m1, ev.m2, ev.spin, ev.color);
}

/* Populate select + initial load */
for(const k in events){
  // select already populated earlier
}
loadEvent('GW150914');

/* event handlers */
eventSelect.addEventListener('change', ()=> loadEvent(eventSelect.value) );

runCustomBtn.addEventListener('click', ()=>{
  const m1 = clamp(parseFloat(m1Input.value) || 30, 1, 1000);
  const m2 = clamp(parseFloat(m2Input.value) || 30, 1, 1000);
  const spin = clamp(parseFloat(spinInput.value) || 0.5, 0, 1);
  // create/overwrite Custom
  events['Custom'] = { m1, m2, spin, color: '#ffd166', desc: `Custom: ${m1} + ${m2} M‚òâ, spin ${spin}` };
  loadEvent('Custom');
});

resetBtn.addEventListener('click', ()=>{
  // clear trails and reload current event defaults
  trailsA = []; trailsB = []; angle = 0;
  loadEvent(eventSelect.value || 'GW150914');
  stopChirpAudio();
});

playChirpBtn.addEventListener('click', async ()=>{
  // ensure user gesture enables audio
  if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  if(audioCtx.state === 'suspended') await audioCtx.resume().catch(()=>{});
  const ev = events[eventSelect.value] || events['Custom'];
  // make sure waveform updated
  generateWaveformSamples(ev.m1, ev.m2, ev.spin);
  // play audio and visuals
  playChirpAudio(ev.m1, ev.m2, ev.spin, ev.color);
});

stopChirpBtn.addEventListener('click', ()=> stopChirpAudio() );

/* make sure audio resumes on first gesture as well (additional safety) */
['click','keydown','pointerdown','touchstart'].forEach(evt => {
  window.addEventListener(evt, ()=> {
    if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume().then(()=>{/* resumed */}).catch(()=>{});
  }, { once:true });
});
</script>
</body>
</html>
